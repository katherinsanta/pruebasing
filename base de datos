USE msdb;
EXECUTE sp_add_job @job_name = 'TestJob';
BEGIN
    WAITFOR TIME '22:20';
    EXECUTE sp_update_job @job_name = 'TestJob',
        @new_name = 'UpdatedJob';
END;
GO
se ejecuta por hora
------------------------------------
BEGIN
    WAITFOR DELAY '02:00';
    EXECUTE sp_helpdb;
END;
GO
se ejecuta por retardo 
----------------------------------
USE AdventureWorks2008R2;
GO
IF OBJECT_ID('dbo.TimeDelay_hh_mm_ss','P') IS NOT NULL
    DROP PROCEDURE dbo.TimeDelay_hh_mm_ss;
GO
CREATE PROCEDURE dbo.TimeDelay_hh_mm_ss 
    (
    @DelayLength char(8)= '00:00:00'
    )
AS
DECLARE @ReturnInfo varchar(255)
IF ISDATE('2000-01-01 ' + @DelayLength + '.000') = 0
    BEGIN
        SELECT @ReturnInfo = 'Invalid time ' + @DelayLength 
        + ',hh:mm:ss, submitted.';
        -- This PRINT statement is for testing, not use in production.
        PRINT @ReturnInfo 
        RETURN(1)
    END
BEGIN
    WAITFOR DELAY @DelayLength
    SELECT @ReturnInfo = 'A total time of ' + @DelayLength + ', 
        hh:mm:ss, has elapsed! Your time is up.'
    -- This PRINT statement is for testing, not use in production.
    PRINT @ReturnInfo;
END;
GO
/* This statement executes the dbo.TimeDelay_hh_mm_ss procedure. */
EXEC TimeDelay_hh_mm_ss '00:00:10';
GO

En el ejemplo siguiente se muestra cómo se puede utilizar una variable local con la opción WAITFOR DELAY. Se crea un procedimiento almacenado que espere un período de tiempo variable y, a continuación, devuelva información al usuario acerca del número de horas, minutos y segundos que han transcurrido.
--------------------------------------------------
https://msdn.microsoft.com/es-es/library/ms189794.aspx
diferencias de horas dias min 
y ejemplos 

---------------------------------------------------
SELECT DATEADD(mm, DATEDIFF(mm,0,getdate()), 0)--primer dia

SELECT dateadd(ms,-3,DATEADD(mm, DATEDIFF(m,0,getdate()  )+1, 0));--ultimo dia Encontrar el primer día del año pasado:

SELECT dateadd(ms,-3,DATEADD(yy, DATEDIFF(yy,0,getdate() ), 0))



SELECT DATEADD(wk, DATEDIFF(wk,0, dateadd(dd,6-datepart(DAY,getdate()),getdate())), 0);
-------------------------------------------------


create  FUNCTION [dbo].[EntreFechasAñoMesDia] (
                                                                                @CadenaInicio AS DATETIME,
                                                                                @CadenaFin AS DATETIME
                                                                        )
RETURNS NVARCHAR (100)
AS
BEGIN
        DECLARE @AñoInicio INT
        DECLARE @MesInicio INT
        DECLARE @DiaInicio INT
        DECLARE @AñoFin INT
        DECLARE @MesFin INT
        DECLARE @DiaFin INT
        DECLARE @Años INT
        DECLARE @Meses INT
        DECLARE @Dias INT
        DECLARE @FechaInicio DATETIME
        DECLARE @FechaFin DATETIME
        DECLARE @Texto NVARCHAR(100)
 
        --Para comprobar las fechas
        --IF isdate(@CadenaInicio)=0 return('La fecha de Inicio no es correcta')
        --IF isdate(@CadenaFin)=0 return ('La fecha de Fin no es correcta')
        IF DATEDIFF(dd, @CadenaInicio, @CadenaFin) = 0 RETURN('La fecha de Inicio es igual que la de Fin')
        --Asigna las cadenas a las fechas, inviertiéndolas si es necesario y cambiando el mensaje de salida.-
 
        IF DATEDIFF(dd, @CadenaInicio, @CadenaFin) > 0
 
        BEGIN
                SET @FechaInicio = @CadenaInicio
                SET @FechaFin = @CadenaFin
                SET @Texto = 'Pasa'
        END
        ELSE
        BEGIN
                SET @FechaInicio = @CadenaFin
                SET @FechaFin = @CadenaInicio
                SET @Texto = 'Falta'
        END
 
        --Asigna los valores individuales de día, mes y año, para hacer los cálculos.-
        SET @DiaInicio = DAY(@FechaInicio)
        SET @MesInicio = MONTH(@FechaInicio)
        SET @AñoInicio = YEAR(@FechaInicio)
 
        SET @DiaFin = DAY(@FechaFin)
        SET @MesFin = MONTH(@FechaFin)
        SET @AñoFin = YEAR(@FechaFin)
 
 
        --Comprueba si el día es menor o igual al de fin.-
        IF @DiaFin - @DiaInicio >= 0
        BEGIN
                SET @Dias = @DiaFin - @DiaInicio
        END
        --Si no, calcula la suma en días, desde el día de Inicio a fin de mes, mas los días de Fin, y le resta uno al mes de Fin.-
        ELSE
        BEGIN
                SET @Dias = (DAY(DATEADD(mm,1,CAST(('01/' + STR(@MesInicio) + '/' + STR(@AñoInicio)) AS DATETIME)) - 1 )- @DiaInicio) + @DiaFin
                SET @MesFin = @MesFin - 1
        END
        --Lo mismo con el mes.-
        IF @MesFin - @MesInicio >= 0
        BEGIN
                SET @Meses = @MesFin - @MesInicio
        END
        ELSE
        BEGIN
                SET @Meses = (@MesFin - @MesInicio) + 12
                SET @AñoFin = @AñoFin - 1
        END
 
        SET @Años = @AñoFin - @AñoInicio
        --A partir de qaquí ya tenemos los vlores del año, mes y día, lo siguiente es para presentarlo correctamente.-
        DECLARE @CadDia AS VARCHAR(20)
        DECLARE @CadMes AS VARCHAR(20)
        DECLARE @CadAño AS VARCHAR(20)
 
        IF @Dias = 0 SET @CadDia = ''
        IF @Dias = 1 SET @CadDia = LTRIM(STR(@Dias)) + ' día '
        IF @Dias > 1 SET @CadDia = LTRIM(STR(@Dias)) + ' días '
 
        IF @Meses = 0 SET @CadMes = ''
        IF @Meses = 1 SET @CadMes = LTRIM(STR(@Meses)) + ' mes'
        IF @Meses > 1 SET @CadMes = LTRIM(STR(@Meses)) + ' meses'
 
 
        IF @Años = 0
        BEGIN
                SET @CadAño = ''
                IF @Meses > 1 SET @Texto = @Texto + 'n'
                IF @Meses = 0 and @Dias >1 SET @Texto = @Texto + 'n'
        END
        IF @Años = 1 SET @CadAño = LTRIM(STR(@Años)) + ' año'
       
        IF @Años > 1
        BEGIN
                SET @CadAño = LTRIM(STR(@Años)) + ' años'
                SET @Texto = @Texto + 'n'
        END
 
        IF @Meses <> 0
        BEGIN
                IF @Dias <> 0
                BEGIN
                        SET @CadMes = @CadMes + ' y '
                        IF @Años <> 0 SET @CadAño = @CadAño + ', '
                END
        ELSE
                IF @Años <> 0 SET @CadAño = @CadAño + ' y '
        END
        ELSE
                IF @Años <> 0 and @Dias <> 0 SET @CadMes = @CadMes + ' y '
--end
 
        SET @Texto = @Texto + ' ' + @CadAño + @CadMes + @CadDia
       
        RETURN @Texto
END

funcion de fechas
---------------------------------------
identificar errores

 BEGIN TRY
DECLARE @num INT
---- Divide by zero to generate Error
SET @num = 5/0
PRINT 'This will not execute'
END TRY
BEGIN CATCH
SELECT ERROR_NUMBER() AS ErrorNumber,
 ERROR_SEVERITY() AS ErrorSeverity,
  ERROR_STATE() AS ErrorState, 
  ERROR_PROCEDURE() AS ErrorProcedure, 
  ERROR_LINE() AS ErrorLine, 
  ERROR_MESSAGE() AS ErrorMessage;
END CATCH;
GO 
------------------------------------
SELECT TOP (100) direccionOrig, direccionDest, nombrePasajero, convert(char(17),fechaServicio,110) as 'fecha', estado, valeAsignado, nombreConductor, convert(char(5),horaServicio,108)as 'Hora servicio', movil, placa 
FROM PDV_SolicitudesTransporte 
WHERE (CAST(fechaServicio AS date) = '20150321') AND (estado IN (2, 9)) order by (fechaServicio )

DECLARE @startdate datetime2 = getdate()
DECLARE @enddate datetime2 = getdate()
SELECT DATEDIFF(day, @startdate, @enddate);
datos de diferencia en fechas
+-------------------------------------------